---
layout: default
title: memcache(四)调优;
tit: 惰性删除；
---
<br>
<hr>
<br>
在整理之前，先给大家导入一个概念：

内存碎片化：在向操作系统不断申请和释放内存的时候，会形成一些很小的内存片段，这种闲置的又没法利用内存的现象。


memcache存储方式：

memcache是利用 slab allocator 来管理内存的，呢么我们首先需要明白 slab allocator 是怎么一回事

 slab allocator ：首先将内存划分成若干个 slab
 class（默认内个1M），然后将每个 slab class 切割成相同的chunk ，需要内存时根据内容大小选择合适的chunk存储数据。如下：

![]({{ site.baseurl }}/img/cookiesession/20160607102556409.png)

如上chunk分布，如果我们memcache要存储一个100byte的数据，呢么我们会选取空的112byte的这个chunk存储数据，如果112的chunk用完了，并不会去选取144，而是将原有的112chunk中旧的数据覆盖掉或者说是剔除，此处等后面具体讲解。


由于chunk的大小都是已经提前‘固定’好的，这样就容易造成内存浪费,比如100byte数据存入112byte中，多余的12byte就被浪费掉了，但是chunk的大小又不能自己设置，只能通过增长因子来调节，呢么这个增长因子的大小设置就非常重要了。下面我们介绍下增长因子。

memcache在启动的时候可以通过 -f 来指定增长因子的大小，默认为1.25，在改参数出现之前增长因子固定是2，因此我们在设置之前需要认真统计缓存大小，根据缓存大小来合理设计增长因子大小。


下面说一下删除：

1、惰性删除：数据过期后并不会直接删除缓存中的数据，因此status时，有信息；新值来占用chunk是会当成空的使用；get数据时，数据过去返回空并且删除缓存中数据。

优点：节省cpu和检测成本

2、Least Recently Used（LRU）这个就是上面说的覆盖的现象了，当某一chunk全部满了，这个时候会将最近最少使用的chunk中数据挤掉并存入。即便数据是永存生效也有可能被挤掉。


最后注意几点memcache的限制(默认)

<pre>
    <code>
    name：256字节，二进制支持65536字节  
    value：1M  
    内存限制：32位系统为2G。  
    如果缓存数据量大会开启多个实例而不是只用一个实例存储
    </code>
</pre>

     